package com.whalekiss.util.concurrent;

import java.io.IOException;
import java.util.Date;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.springframework.util.StringUtils;

import com.whalekiss.util.concurrent.daemon.PlatformDaemonConst;
import com.whalekiss.util.concurrent.daemon.PlatformDaemonLogger;
import com.whalekiss.util.concurrent.daemon.PlatformDaemonUtil;

/**
 * A non fully functional dirty wrapper implementation of the java's
 * Reentrantreadwritelock. This class is not meant to be a replacement to the
 * java's implementation, but provides a hacky way of making sure that with
 * minimal code changes, the calls to <code>lock()</code> are masked into a
 * timeout based call (<code> tryLock </code>). This is to be in place till,
 * we have a better way of detecting deadlocks caused by these locks (which is
 * something that would be given by jdk1.6 jmx.
 * 
 * jmorefield - Reworked to correct thread ID logging, correctly implement
 * the ReadWriteLock and Lock interfaces, and add a dead-lock protected
 * {@link Condition} implementation.
 * 
 * @author <A href=mailto:chgarre@expedia.com>chgarre</a>
 * @author <a href="mailto:jmorefield@expedia.com">jmorefield</a>
 */
public class PlatformReentrantReadWriteLock implements ReadWriteLock
{
	/* some other NT events are defined in PlatformDaemonConst */
	/** NT event id of a read timeout */
	public static final int READ_TIMEOUT_NTEVENT_ID = 2500;

	/** NT event id of a write timeout */
	public static final int WRITE_TIMEOUT_NTEVENT_ID = 2501;
	
	/** NT event id of an await timeout */
	public static final int AWAIT_TIMEOUT_NTEVENT_ID = 2502;

	/** The super family for all lock settings. */
	public static final String LOCK_SUPER_FAMILY_NAME = "com.expedia.e3.platform.foundation.core."
			+ "util.concurrent.PlatformReentrantReadWriteLockRegistry";

	public static final String LOCK_TIMEOUT_SETTING_NAME = "timeout";

	/* autogenerated for serialization */
	private static final long serialVersionUID = 7532741607039269546L;

	/** 
	 * lock timeout in milliseconds - default is initially set here and if
	 * the service is registered to get config updates, it will be updated
	 * to whatever is specified in the ApplicationConfiguration database.
	 */
	private static long s_defaultTimeout = 35000;

	/* stats used by MBean */
	
	/** to indicate how many times reads have timed out */
	private static long s_readTimeoutCount = 0;

	/** to indicate how many times writes have timed out */
	private static long s_writeTimeoutCount = 0;

	/** this is the time when the counters have been started */
	private static long s_countResetTime = System.currentTimeMillis();
	
	private final ConcurrentMap<Long, AtomicInteger> m_threadsHoldingLock =
		new ConcurrentHashMap<Long, AtomicInteger>();

	/** reentrant read write lock, we are wrapping */
	private ReentrantReadWriteLock m_realReadWriteLock = new ReentrantReadWriteLock();

	/** read lock we are wrapping */
	private PlatformReadLock m_readLock;

	/** write lock we are wrapping */
	private PlatformWriteLock m_writeLock;

	/**
	 * Default constructor. This will use a non fair policy.
	 */
	public PlatformReentrantReadWriteLock()
	{
		this(false);
	}

	public PlatformReentrantReadWriteLock(boolean fair)
	{
		// -1 indicates that we will have to use default.
		this(fair, -1);
	}

	/**
	 * Default constructor where timeout is specified, and this uses 
	 * a non fair policy.
	 * @param timeout timeout in millseconds.
	 */
	public PlatformReentrantReadWriteLock(long timeout)
	{
		this(false, timeout);
	}

	/**
	 * Creates a platform read write lock, with the given fairness policy.
	 * 
	 * @param fair - fairness policy. true for fair, false for no fair.
	 * @param timeout - timeout in millseconds.
	 */
	public PlatformReentrantReadWriteLock(boolean fair, long timeout)
	{
		this.m_realReadWriteLock = new ReentrantReadWriteLock(fair);
		m_readLock = this.new PlatformReadLock(m_realReadWriteLock, timeout);
		m_writeLock = this.new PlatformWriteLock(m_realReadWriteLock, timeout);
	}

	/**
	 * Returns the read lock.
	 * 
	 * @return - Read Lock
	 */
	public PlatformReadLock readLock()
	{
		return m_readLock;
	}

	/**
	 * Returns the write lock.
	 * 
	 * @return - Write lock.
	 */
	public PlatformWriteLock writeLock()
	{
		return m_writeLock;
	}

	/**
	 * Helper method to gets a short error string.
	 * 
	 * @param readorwrite -
	 *                usually either <code>"read"</code> or
	 *                <code>"write"</code>
	 * @param holdingThreadID -
	 *                The id of the thread holding the lock, thats why the
	 *                error. <br>
	 *                <code> -1 </code> indicates no holding thread.
	 * @return - short error string.
	 */
	public static String getShortErrorString(String readorwrite, long holdingThreadID)
	{
		String errorMessage = "Thread " + Thread.currentThread().getName() + "(" + Thread.currentThread().getId() + ")"
								+ " Could not acquire " + readorwrite + " lock ";
		if (holdingThreadID != -1)
		{
			errorMessage = errorMessage + " - As it is currently being held by Thread ID = " + holdingThreadID;
		}

		return errorMessage;
	}

	/**
	 * Helper method to gets a short error string.
	 * 
	 * @param readorwrite -
	 *                usually either <code>"acquire read"</code> or
	 *                <code>"acquire write"</code>
	 * @param holdingThreadIDs -
	 *                The id(s) of the thread(s) holding the lock, thats why the
	 *                error. <br>
	 *                <code> null </code> indicates no holding thread.
	 * @return - short error string.
	 */
	public static String getShortErrorString(String readorwrite, Long[] holdingThreadIDs)
	{
		String errorMessage = "Thread " + Thread.currentThread().getName() + "(" + Thread.currentThread().getId() + ")"
								+ " Could not " + readorwrite + " lock ";
		if (null != holdingThreadIDs && 0 < holdingThreadIDs.length)
		{
			errorMessage = errorMessage + " - It is currently being held by Thread ID(s) = "
				+ StringUtils.arrayToCommaDelimitedString(holdingThreadIDs);
		}

		return errorMessage;
	}

	/**
	 * Gets the default timeout.
	 * @return
	 */
	public static long getDefaultTimeout()
	{
		return s_defaultTimeout;
	}

	/**
	 * Sets the default timeout.
	 * @param timeout
	 */
	public static void setDefaultTimeout(long timeout)
	{
		s_defaultTimeout = timeout;
	}

	/**
	 * Helper method, to get an error string with stack traces of both the
	 * calling thread and the lock holding thread.
	 * 
	 * @param readorwrite -
	 *                usually either <code>"read"</code> or
	 *                <code>"write"</code>
	 * @param holdingThreadID -
	 *                The id of the thread holding the lock, thats why the
	 *                error. <code> -1 </code> indicates no holding thread.
	 * @return - long error string, with stack traces.
	 */
	public static String getErrorString(String readorwrite, long holdingThreadID)
	{
		String errorMessage = getShortErrorString(readorwrite, holdingThreadID);
		if (holdingThreadID != -1)
		{
			errorMessage = errorMessage + PlatformDaemonUtil.CARRIAGE_RETURN_NEWLINE
					+ PlatformDaemonUtil.threadStackDump(holdingThreadID, 
							"====Stack dump of the thread holding the LOCK ====");
		}
		errorMessage = errorMessage + PlatformDaemonUtil.CARRIAGE_RETURN_NEWLINE
					+ PlatformDaemonUtil.threadStackDump(Thread.currentThread().getId(),
							"==== Stack dump of the thread requesting for LOCK  ====");
		return errorMessage;
	}

	/* these methods are for internal use by MBEAN 
	 * 
	 */

	public static long getReadTimeoutCount()
	{
		return s_readTimeoutCount;
	}

	public static void incrementReadTimeoutCount()
	{
		s_readTimeoutCount++;
	}

	public static long getWriteTimeoutCount()
	{
		return s_writeTimeoutCount;
	}

	public static void incrementWriteTimeoutCount()
	{
		s_writeTimeoutCount++;
	}

	public static void resetCounts()
	{
		s_readTimeoutCount = 0;
		s_writeTimeoutCount = 0;
		s_countResetTime = System.currentTimeMillis();
	}

	public static long getCountResetTime()
	{
		return s_countResetTime;
	}
	
	private void decrementThreadCount()
	{
		Long threadID = Thread.currentThread().getId();
		AtomicInteger count = m_threadsHoldingLock.get(threadID);
		if (null != count)
		{
			if (1 > count.decrementAndGet())
			{
				m_threadsHoldingLock.remove(threadID);
			}
		}
	}

	private void incrementThreadCount()
	{
		Long threadID = Thread.currentThread().getId();
		AtomicInteger count = m_threadsHoldingLock.get(threadID);
		if (null != count)
		{
			count.incrementAndGet();
		}
		else
		{
			m_threadsHoldingLock.put(threadID, new AtomicInteger(1));
		}
	}
	
	private Long[] threadIDsHoldingLock()
	{
		return m_threadsHoldingLock.keySet().toArray(new Long[0]);
	}
	
	/**
	 * @see java.util.concurrent.locks.Lock#newCondition()
	 */
	private Condition newCondition(Condition realCondition, long timeout)
	{
		return this.new PlatformLockCondition(realCondition, timeout);
	}

	/**
	 * Wraps the await calls in a deadlock-safe manner similar to our lock implementation above.
	 * 
	 * @author <a href="mailto:jmorefield@expedia.com">jmorefield</a>
	 *
	 */
	protected class PlatformLockCondition implements Condition
	{
		private final Condition m_realCondition;
		
		private final long m_timeout;
		
		protected PlatformLockCondition(Condition realCondition, long timeout)
		{
			m_realCondition = realCondition;
			m_timeout = timeout;
		}

		/** 
		 * @see java.util.concurrent.locks.Condition#await()
		 */
		public void await() throws InterruptedException
		{
			try
			{
				awaitUninterruptibly();
			}
			catch (PlatformLockAquireFailedException ex)
			{
				if (ex.getCause() instanceof InterruptedException)
				{
					throw (InterruptedException) ex.getCause();
				}
				else
				{
					throw ex;
				}
			}
		}

		/** 
		 * @see java.util.concurrent.locks.Condition#await(long, java.util.concurrent.TimeUnit)
		 */
		public boolean await(long time, TimeUnit unit) throws InterruptedException
		{
			return m_realCondition.await(time, unit);
		}

		/** 
		 * @see java.util.concurrent.locks.Condition#awaitNanos(long)
		 */
		public long awaitNanos(long nanosTimeout) throws InterruptedException
		{
			return m_realCondition.awaitNanos(nanosTimeout);
		}

		/** 
		 * @see java.util.concurrent.locks.Condition#awaitUninterruptibly()
		 */
		public void awaitUninterruptibly()
		{
			boolean awaitSuccess = false;
			InterruptedException awaitException = null;
			
			try
			{
				long timeout = m_timeout;
				if (1 > timeout)
				{
					timeout = PlatformReentrantReadWriteLock.getDefaultTimeout();
				}

				awaitSuccess = m_realCondition.await(timeout, TimeUnit.MILLISECONDS);
			}
			catch (InterruptedException e)
			{
				/*
				 * this means that the calling thread has been interrupted.
				 * in this case it's OK, since the thread has been interrupted
				 * we can consider as though await failed.
				 */
				awaitException = e;
			}
			finally
			{

				// raise NT event and log it. Also throw an unchecked exception.
				if (!awaitSuccess)
				{
					String errorString = PlatformReentrantReadWriteLock.getShortErrorString("await",
							PlatformReentrantReadWriteLock.this.threadIDsHoldingLock());
					PlatformLockAquireFailedException plafe = null;
					if ( null != awaitException )
					{
						plafe = new PlatformLockAquireFailedException(errorString, awaitException);
					}
					else
					{
						plafe = new PlatformLockAquireFailedException(errorString);
					}

					String logEntry = errorString;

					String prefix = "";
					// log to file
					try
					{
						PlatformDaemonLogger.forceNewLogFile();

						PlatformDaemonLogger.writeToFile(PlatformDaemonConst.CARRIAGE_RETURN_NEWLINE + logEntry
								+ PlatformDaemonConst.CARRIAGE_RETURN_NEWLINE + PlatformDaemonUtil.dumpStackTrace()
								+ PlatformDaemonConst.CARRIAGE_RETURN_NEWLINE);
						if (null != PlatformDaemonLogger.getLoggerFile())
						{
							prefix = "Full Thread dump Logged to file = "
								+ PlatformDaemonLogger.getLoggerFile().getPath();
						}
						else
						{
							prefix = "Unable to log to a file";
						}

					}
					catch (IOException ex)
					{
						prefix = "Unable to log to a file .. , due to " + ex.getMessage();
					}

					prefix = prefix + PlatformDaemonConst.CARRIAGE_RETURN_NEWLINE;

					// raise an NT event
					PlatformDaemonUtil.logErrorToNTEvent(AWAIT_TIMEOUT_NTEVENT_ID, prefix + logEntry,
							this.getClass().getName());
					// now throw the (unchecked) exception
					throw plafe;
				}
			}
		}

		/** 
		 * @see java.util.concurrent.locks.Condition#awaitUntil(java.util.Date)
		 */
		public boolean awaitUntil(Date deadline) throws InterruptedException
		{
			return m_realCondition.awaitUntil(deadline);
		}

		/** 
		 * @see java.util.concurrent.locks.Condition#signal()
		 */
		public void signal()
		{
			m_realCondition.signal();
		}

		/** 
		 * @see java.util.concurrent.locks.Condition#signalAll()
		 */
		public void signalAll()
		{
			m_realCondition.signalAll();
		}
	}

	/**
	 * Write lock implementation wrapper, thats wrapping java's readlock.
	 * 
	 * @author <A href=mailto:chgarre@expedia.com>chgarre</a>
	 * 
	 */
	protected abstract class PlatformLock implements Lock
	{
		private static final long serialVersionUID = -8189794129551428594L;

		private Lock m_realLock;

		private long m_timeout;

		/**
		 * Returns a <code> writelock </code>.
		 * 
		 * @param lock -
		 *                The parent reentrant read write lock.
		 * @param timeout -
		 *                lock timeout.
		 */
		protected PlatformLock(Lock lock, long timeout)
		{
			this.m_realLock = lock;
			m_timeout = timeout;
		}
		
		/**
		 * Returns the desired verb phrase used when logging errors.
		 * 
		 * For example "acquire READ", "acquire WRITE".
		 * 
		 * @return the desired verb phrase to use for error logging.
		 */
		protected abstract String getErrorVerbPhrase();
		
		/**
		 * Returns the event ID to be used when logging errors.
		 * 
		 * @return the desired event ID to use for error logging.
		 */
		protected abstract int getTimeoutEventID();

		/**
		 * This lock method will not block infinitely like, the other locks of
		 * java concurrent. This is a timeout lock, just like
		 * {@link #ReadLock.tryLock(timeout)} .
		 * 
		 * This method redirects calls to tryLock with a timeout.
		 * 
		 * <pre>
		 * 1. When there is a timeout, it means that the lock was not acquired, in which case it will
		 * throw  an unchecked exception of the type {@link #PlatformLockAquireFailedException}. 
		 * 
		 * 2. If the thread was interrupted, lock acquire attempt is abandoned, and we treat it 
		 * as though lock was not required ( as a special case of everything is fine).
		 * 
		 * 3. If there is no timeout, it indicates that the lock was acquired within the given time
		 * in which case we will be happy, and nothing is logged, and we store the reference
		 * of the current thread to a local variable that tells us which thread is holding the 
		 * lock.
		 * 
		 */
		public final void lock()
		{
			boolean acquireSuccess = false;
			InterruptedException tryLockException = null;
			
			try
			{
				long timeout = m_timeout;
				if (1 > timeout)
				{
					timeout = PlatformReentrantReadWriteLock.getDefaultTimeout();
				}

				acquireSuccess = m_realLock.tryLock(timeout, TimeUnit.MILLISECONDS);
				if (acquireSuccess)
				{
					PlatformReentrantReadWriteLock.this.incrementThreadCount();
				}

			}
			catch (InterruptedException e)
			{
				/*
				 * this means that the calling thread has been interrupted.
				 * in this case it's OK, since the thread has been interrupted
				 * we can consider as though lock is not acquired.
				 */
				tryLockException = e;
			}
			finally
			{

				// raise NT event and log it. Also throw an unchecked exception.
				if (!acquireSuccess)
				{
					String errorString = PlatformReentrantReadWriteLock.getShortErrorString(getErrorVerbPhrase(),
							PlatformReentrantReadWriteLock.this.threadIDsHoldingLock());
					PlatformLockAquireFailedException plafe = null;
					if ( null != tryLockException )
					{
						plafe = new PlatformLockAquireFailedException(errorString, tryLockException);
					}
					else
					{
						plafe = new PlatformLockAquireFailedException(errorString);
					}

					String logEntry = errorString;

					String prefix = "";
					// log to file
					try
					{
						PlatformDaemonLogger.forceNewLogFile();

						PlatformDaemonLogger.writeToFile(PlatformDaemonConst.CARRIAGE_RETURN_NEWLINE + logEntry
								+ PlatformDaemonConst.CARRIAGE_RETURN_NEWLINE + PlatformDaemonUtil.dumpStackTrace()
								+ PlatformDaemonConst.CARRIAGE_RETURN_NEWLINE);
						if (null != PlatformDaemonLogger.getLoggerFile())
						{
							prefix = "Full Thread dump Logged to file = "
								+ PlatformDaemonLogger.getLoggerFile().getPath();
						}
						else
						{
							prefix = "Unable to log to a file";
						}

					}
					catch (IOException ex)
					{
						prefix = "Unable to log to a file .. , due to " + ex.getMessage();
					}

					prefix = prefix + PlatformDaemonConst.CARRIAGE_RETURN_NEWLINE;

					// raise an NT event
					PlatformDaemonUtil.logErrorToNTEvent(getTimeoutEventID(), prefix + logEntry,
							this.getClass().getName());
					// now throw the (unchecked) exception
					throw plafe;
				}
			}
		}

		/**
		 * releases the lock.
		 */
		public final void unlock()
		{
			PlatformReentrantReadWriteLock.this.decrementThreadCount();
			m_realLock.unlock();
		}

		/**
		 * @see #lock()
		 */
		public final void lockInterruptibly() throws InterruptedException
		{
			try
			{
				lock();
			}
			catch (PlatformLockAquireFailedException ex)
			{
				if (ex.getCause() instanceof InterruptedException)
				{
					throw (InterruptedException) ex.getCause();
				}
				else
				{
					throw ex;
				}
			}
		}

		/**
		 * @see java.util.concurrent.locks.Lock#newCondition()
		 */
		public final Condition newCondition()
		{
			return PlatformReentrantReadWriteLock.this.newCondition(m_realLock.newCondition(), m_timeout);
		}

		public String toString()
		{
			return m_realLock.toString();
		}

		/**
		 * @see java.util.concurrent.locks.Lock#tryLock()
		 */
		public final boolean tryLock()
		{
			boolean success = false;
			try
			{
				success = m_realLock.tryLock();
			}
			finally
			{
				if (success)
				{
					PlatformReentrantReadWriteLock.this.incrementThreadCount();
				}
			}
			return success;
		}

		/**
		 * @see java.util.concurrent.locks.Lock#tryLock(long, java.util.concurrent.TimeUnit)
		 */
		public final boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException
		{
			boolean success = false;
			try
			{
				success = m_realLock.tryLock(timeout, unit);
			}
			finally
			{
				if (success)
				{
					PlatformReentrantReadWriteLock.this.incrementThreadCount();
				}
			}
			return success;
		}

	}
	
	/**
	 * A ReadLock, that is wrapping the java's read lock. It will forward the
	 * calls made to <code> lock() </code> to the wrapping real readlocks ,
	 * <code> tryLock() </code> method with a timeout.
	 * 
	 * 
	 * @author <A href=mailto:chgarre@expedia.com>chgarre</a>
	 */
	public class PlatformReadLock extends PlatformLock
	{

		/**
		 * Creates a read lock.
		 * 
		 * @param lock -
		 *                The reentrant read write lock, is passed, so that we
		 *                can capture the read lock of that , and then pass
		 *                calls to that read lock.
		 * 
		 * @param timeout -
		 *                lock timeout.
		 */
		public PlatformReadLock(ReentrantReadWriteLock lock, long timeout)
		{
			super(lock.readLock(), timeout);
		}

		protected String getErrorVerbPhrase()
		{
			return "acquire READ";
		}
		
		protected int getTimeoutEventID()
		{
			return READ_TIMEOUT_NTEVENT_ID;
		}
	}

	/**
	 * Write lock implementation wrapper, thats wrapping java's readlock.
	 * 
	 * @author <A href=mailto:chgarre@expedia.com>chgarre</a>
	 * 
	 */
	public class PlatformWriteLock extends PlatformLock
	{

		/**
		 * Returns a <code> writelock </code>.
		 * 
		 * @param lock -
		 *                The parent reentrant read write lock.
		 * @param timeout -
		 *                lock timeout.
		 */
		public PlatformWriteLock(ReentrantReadWriteLock lock, long timeout)
		{
			super(lock.writeLock(), timeout);
		}

		protected String getErrorVerbPhrase()
		{
			return "acquire WRITE";
		}
		
		protected int getTimeoutEventID()
		{
			return WRITE_TIMEOUT_NTEVENT_ID;
		}
	}
}
